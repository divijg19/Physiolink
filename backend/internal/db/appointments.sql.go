// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: appointments.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const bookAppointmentTxLockSlot = `-- name: BookAppointmentTxLockSlot :one
SELECT id, therapist_id, start_ts, end_ts, status
FROM availability_slots
WHERE id = $1
FOR UPDATE
`

type BookAppointmentTxLockSlotRow struct {
	ID          uuid.UUID
	TherapistID uuid.UUID
	StartTs     time.Time
	EndTs       time.Time
	Status      string
}

// params: slot_id uuid
func (q *Queries) BookAppointmentTxLockSlot(ctx context.Context, id uuid.UUID) (BookAppointmentTxLockSlotRow, error) {
	row := q.db.QueryRowContext(ctx, bookAppointmentTxLockSlot, id)
	var i BookAppointmentTxLockSlotRow
	err := row.Scan(
		&i.ID,
		&i.TherapistID,
		&i.StartTs,
		&i.EndTs,
		&i.Status,
	)
	return i, err
}

const createAvailabilitySlots = `-- name: CreateAvailabilitySlots :exec
INSERT INTO availability_slots (therapist_id, start_ts, end_ts, status)
VALUES ($1, $2, $3, 'open')
ON CONFLICT DO NOTHING
`

type CreateAvailabilitySlotsParams struct {
	TherapistID uuid.UUID
	StartTs     time.Time
	EndTs       time.Time
}

// params: therapist_id uuid, start_ts timestamptz, end_ts timestamptz
func (q *Queries) CreateAvailabilitySlots(ctx context.Context, arg CreateAvailabilitySlotsParams) error {
	_, err := q.db.ExecContext(ctx, createAvailabilitySlots, arg.TherapistID, arg.StartTs, arg.EndTs)
	return err
}

const getAppointmentSlotStartTime = `-- name: GetAppointmentSlotStartTime :one
SELECT a.slot_id, s.start_ts
FROM appointments a
JOIN availability_slots s ON s.id = a.slot_id
WHERE a.id = $1
`

type GetAppointmentSlotStartTimeRow struct {
	SlotID  uuid.NullUUID
	StartTs time.Time
}

// params: appointment_id uuid
func (q *Queries) GetAppointmentSlotStartTime(ctx context.Context, id uuid.UUID) (GetAppointmentSlotStartTimeRow, error) {
	row := q.db.QueryRowContext(ctx, getAppointmentSlotStartTime, id)
	var i GetAppointmentSlotStartTimeRow
	err := row.Scan(&i.SlotID, &i.StartTs)
	return i, err
}

const getAppointmentTherapistID = `-- name: GetAppointmentTherapistID :one
SELECT therapist_id
FROM appointments
WHERE id = $1
`

// params: appointment_id uuid
func (q *Queries) GetAppointmentTherapistID(ctx context.Context, id uuid.UUID) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getAppointmentTherapistID, id)
	var therapist_id uuid.UUID
	err := row.Scan(&therapist_id)
	return therapist_id, err
}

const getTherapistOpenSlots = `-- name: GetTherapistOpenSlots :many
SELECT id, therapist_id, start_ts, end_ts, status
FROM availability_slots
WHERE therapist_id = $1 AND status = 'open'
ORDER BY start_ts ASC
`

type GetTherapistOpenSlotsRow struct {
	ID          uuid.UUID
	TherapistID uuid.UUID
	StartTs     time.Time
	EndTs       time.Time
	Status      string
}

// params: therapist_id uuid
func (q *Queries) GetTherapistOpenSlots(ctx context.Context, therapistID uuid.UUID) ([]GetTherapistOpenSlotsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTherapistOpenSlots, therapistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTherapistOpenSlotsRow
	for rows.Next() {
		var i GetTherapistOpenSlotsRow
		if err := rows.Scan(
			&i.ID,
			&i.TherapistID,
			&i.StartTs,
			&i.EndTs,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAppointment = `-- name: InsertAppointment :one
INSERT INTO appointments (slot_id, patient_id, therapist_id, status, notes)
VALUES ($1, $2, $3, $4, $5)
RETURNING id
`

type InsertAppointmentParams struct {
	SlotID      uuid.NullUUID
	PatientID   uuid.UUID
	TherapistID uuid.UUID
	Status      string
	Notes       sql.NullString
}

// params: slot_id uuid, patient_id uuid, therapist_id uuid, status text, notes text
func (q *Queries) InsertAppointment(ctx context.Context, arg InsertAppointmentParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, insertAppointment,
		arg.SlotID,
		arg.PatientID,
		arg.TherapistID,
		arg.Status,
		arg.Notes,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const insertReminder = `-- name: InsertReminder :exec
INSERT INTO reminders (appointment_id, scheduled_for, payload)
VALUES ($1, $2, $3)
`

type InsertReminderParams struct {
	AppointmentID uuid.UUID
	ScheduledFor  time.Time
	Payload       pqtype.NullRawMessage
}

// params: appointment_id uuid, scheduled_for timestamptz, payload jsonb
func (q *Queries) InsertReminder(ctx context.Context, arg InsertReminderParams) error {
	_, err := q.db.ExecContext(ctx, insertReminder, arg.AppointmentID, arg.ScheduledFor, arg.Payload)
	return err
}

const listMyAppointmentsWithDetails = `-- name: ListMyAppointmentsWithDetails :many
SELECT 
    a.id, 
    a.therapist_id, 
    a.patient_id, 
    a.status, 
    s.start_ts, 
    s.end_ts,
    p_pt.display_name as pt_display_name, 
    p_pt.profile_extra as pt_profile_extra,
    p_pa.display_name as pa_display_name, 
    p_pa.profile_extra as pa_profile_extra
FROM appointments a
JOIN availability_slots s ON s.id = a.slot_id
LEFT JOIN profiles p_pt ON p_pt.user_id = a.therapist_id
LEFT JOIN profiles p_pa ON p_pa.user_id = a.patient_id
WHERE CASE WHEN $2 = 'pt' THEN a.therapist_id = $1 ELSE a.patient_id = $1 END
ORDER BY s.start_ts ASC
`

type ListMyAppointmentsWithDetailsParams struct {
	TherapistID uuid.UUID
	Column2     interface{}
}

type ListMyAppointmentsWithDetailsRow struct {
	ID             uuid.UUID
	TherapistID    uuid.UUID
	PatientID      uuid.UUID
	Status         string
	StartTs        time.Time
	EndTs          time.Time
	PtDisplayName  sql.NullString
	PtProfileExtra pqtype.NullRawMessage
	PaDisplayName  sql.NullString
	PaProfileExtra pqtype.NullRawMessage
}

// params: user_id uuid, role text
func (q *Queries) ListMyAppointmentsWithDetails(ctx context.Context, arg ListMyAppointmentsWithDetailsParams) ([]ListMyAppointmentsWithDetailsRow, error) {
	rows, err := q.db.QueryContext(ctx, listMyAppointmentsWithDetails, arg.TherapistID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMyAppointmentsWithDetailsRow
	for rows.Next() {
		var i ListMyAppointmentsWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.TherapistID,
			&i.PatientID,
			&i.Status,
			&i.StartTs,
			&i.EndTs,
			&i.PtDisplayName,
			&i.PtProfileExtra,
			&i.PaDisplayName,
			&i.PaProfileExtra,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAppointmentStatus = `-- name: UpdateAppointmentStatus :exec
UPDATE appointments
SET status = $2, updated_at = now()
WHERE id = $1
`

type UpdateAppointmentStatusParams struct {
	ID     uuid.UUID
	Status string
}

// params: appointment_id uuid, status text
func (q *Queries) UpdateAppointmentStatus(ctx context.Context, arg UpdateAppointmentStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateAppointmentStatus, arg.ID, arg.Status)
	return err
}

const updateSlotStatus = `-- name: UpdateSlotStatus :exec
UPDATE availability_slots
SET status = $2
WHERE id = $1
`

type UpdateSlotStatusParams struct {
	ID     uuid.UUID
	Status string
}

// params: slot_id uuid, status text
func (q *Queries) UpdateSlotStatus(ctx context.Context, arg UpdateSlotStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateSlotStatus, arg.ID, arg.Status)
	return err
}
