// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reviews.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createReview = `-- name: CreateReview :one
INSERT INTO reviews (appointment_id, patient_id, rating, comment)
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateReviewParams struct {
	AppointmentID uuid.UUID
	PatientID     uuid.UUID
	Rating        int32
	Comment       sql.NullString
}

// params: appointment_id uuid, patient_id uuid, rating int, comment text
func (q *Queries) CreateReview(ctx context.Context, arg CreateReviewParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createReview,
		arg.AppointmentID,
		arg.PatientID,
		arg.Rating,
		arg.Comment,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getAppointmentForReview = `-- name: GetAppointmentForReview :one
SELECT id
FROM appointments
WHERE id = $1 AND patient_id = $2 AND status = 'confirmed'
`

type GetAppointmentForReviewParams struct {
	ID        uuid.UUID
	PatientID uuid.UUID
}

// params: appointment_id uuid, patient_id uuid
func (q *Queries) GetAppointmentForReview(ctx context.Context, arg GetAppointmentForReviewParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getAppointmentForReview, arg.ID, arg.PatientID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getReviewsForTherapist = `-- name: GetReviewsForTherapist :many
SELECT r.id::text as review_id, r.patient_id, r.rating, r.comment,
       p.display_name as patient_name, r.created_at
FROM reviews r
JOIN appointments a ON a.id = r.appointment_id
LEFT JOIN profiles p ON p.user_id = r.patient_id
WHERE a.therapist_id = $1
ORDER BY r.created_at DESC
`

type GetReviewsForTherapistRow struct {
	ReviewID    string
	PatientID   uuid.UUID
	Rating      int32
	Comment     sql.NullString
	PatientName sql.NullString
	CreatedAt   time.Time
}

// params: therapist_id uuid
func (q *Queries) GetReviewsForTherapist(ctx context.Context, therapistID uuid.UUID) ([]GetReviewsForTherapistRow, error) {
	rows, err := q.db.QueryContext(ctx, getReviewsForTherapist, therapistID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewsForTherapistRow
	for rows.Next() {
		var i GetReviewsForTherapistRow
		if err := rows.Scan(
			&i.ReviewID,
			&i.PatientID,
			&i.Rating,
			&i.Comment,
			&i.PatientName,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTherapistAverageRating = `-- name: GetTherapistAverageRating :one
SELECT AVG(r.rating)::float as avg_rating
FROM reviews r
JOIN appointments a ON a.id = r.appointment_id
WHERE a.therapist_id = $1
`

// params: therapist_id uuid
func (q *Queries) GetTherapistAverageRating(ctx context.Context, therapistID uuid.UUID) (float64, error) {
	row := q.db.QueryRowContext(ctx, getTherapistAverageRating, therapistID)
	var avg_rating float64
	err := row.Scan(&avg_rating)
	return avg_rating, err
}

const updateProfileRating = `-- name: UpdateProfileRating :exec
UPDATE profiles
SET rating = $2
WHERE user_id = $1
`

type UpdateProfileRatingParams struct {
	UserID uuid.UUID
	Rating sql.NullString
}

// params: user_id uuid, rating float
func (q *Queries) UpdateProfileRating(ctx context.Context, arg UpdateProfileRatingParams) error {
	_, err := q.db.ExecContext(ctx, updateProfileRating, arg.UserID, arg.Rating)
	return err
}
