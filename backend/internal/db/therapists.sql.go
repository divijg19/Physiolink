// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: therapists.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const getAvailabilityCounts = `-- name: GetAvailabilityCounts :many
SELECT therapist_id::text, COUNT(*)
FROM availability_slots
WHERE therapist_id = ANY($1::uuid[])
  AND status = 'open'
  AND ($2 = '' OR start_ts::date = $2::date)
GROUP BY therapist_id
`

type GetAvailabilityCountsParams struct {
	Column1 []uuid.UUID
	Column2 interface{}
}

type GetAvailabilityCountsRow struct {
	TherapistID string
	Count       int64
}

// params: therapist_ids text[], date text
func (q *Queries) GetAvailabilityCounts(ctx context.Context, arg GetAvailabilityCountsParams) ([]GetAvailabilityCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAvailabilityCounts, pq.Array(arg.Column1), arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailabilityCountsRow
	for rows.Next() {
		var i GetAvailabilityCountsRow
		if err := rows.Scan(&i.TherapistID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewCounts = `-- name: GetReviewCounts :many
SELECT a.therapist_id::text, COUNT(r.id)
FROM appointments a
JOIN reviews r ON r.appointment_id = a.id
WHERE a.therapist_id = ANY($1::uuid[])
GROUP BY a.therapist_id
`

type GetReviewCountsRow struct {
	ATherapistID string
	Count        int64
}

// params: therapist_ids text[]
func (q *Queries) GetReviewCounts(ctx context.Context, dollar_1 []uuid.UUID) ([]GetReviewCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, getReviewCounts, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewCountsRow
	for rows.Next() {
		var i GetReviewCountsRow
		if err := rows.Scan(&i.ATherapistID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTherapistAvailabilitySlots = `-- name: GetTherapistAvailabilitySlots :many
SELECT id::text, start_ts, end_ts
FROM availability_slots
WHERE therapist_id = $1 AND status = 'open' AND ($2 = '' OR start_ts::date = $2::date)
ORDER BY start_ts ASC
LIMIT $3
`

type GetTherapistAvailabilitySlotsParams struct {
	TherapistID uuid.UUID
	Column2     interface{}
	Limit       int32
}

type GetTherapistAvailabilitySlotsRow struct {
	ID      string
	StartTs time.Time
	EndTs   time.Time
}

// params: therapist_id uuid, date text, limit int
func (q *Queries) GetTherapistAvailabilitySlots(ctx context.Context, arg GetTherapistAvailabilitySlotsParams) ([]GetTherapistAvailabilitySlotsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTherapistAvailabilitySlots, arg.TherapistID, arg.Column2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTherapistAvailabilitySlotsRow
	for rows.Next() {
		var i GetTherapistAvailabilitySlotsRow
		if err := rows.Scan(&i.ID, &i.StartTs, &i.EndTs); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTherapistByID = `-- name: GetTherapistByID :one
SELECT u.id, u.email, COALESCE(p.display_name,''), COALESCE(p.specialties, ARRAY[]::text[]), p.address, COALESCE(p.bio,''), p.rating
FROM users u LEFT JOIN profiles p ON p.user_id = u.id
WHERE u.id = $1 AND u.role = 'pt'
`

type GetTherapistByIDRow struct {
	ID          uuid.UUID
	Email       string
	DisplayName string
	Specialties []string
	Address     pqtype.NullRawMessage
	Bio         string
	Rating      sql.NullString
}

// params: id uuid
func (q *Queries) GetTherapistByID(ctx context.Context, id uuid.UUID) (GetTherapistByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getTherapistByID, id)
	var i GetTherapistByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.DisplayName,
		pq.Array(&i.Specialties),
		&i.Address,
		&i.Bio,
		&i.Rating,
	)
	return i, err
}

const getTherapistCount = `-- name: GetTherapistCount :one
SELECT COUNT(*)
FROM users u
LEFT JOIN profiles p ON p.user_id = u.id
WHERE u.role = 'pt'
  AND ($1 = '' OR p.specialties::text ILIKE $1)
  AND ($2 = '' OR p.address::text ILIKE $2)
`

type GetTherapistCountParams struct {
	Column1 interface{}
	Column2 interface{}
}

// params: specialty text, location text
func (q *Queries) GetTherapistCount(ctx context.Context, arg GetTherapistCountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTherapistCount, arg.Column1, arg.Column2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTherapistReviewCount = `-- name: GetTherapistReviewCount :one
SELECT COUNT(r.id)
FROM appointments a JOIN reviews r ON r.appointment_id = a.id
WHERE a.therapist_id = $1
`

// params: therapist_id uuid
func (q *Queries) GetTherapistReviewCount(ctx context.Context, therapistID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTherapistReviewCount, therapistID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTherapists = `-- name: GetTherapists :many
SELECT u.id, u.email, COALESCE(p.display_name,'') AS display_name,
       COALESCE(p.specialties, ARRAY[]::text[]) AS specialties,
       p.address, p.rating
FROM users u
LEFT JOIN profiles p ON p.user_id = u.id
WHERE u.role = 'pt'
  AND ($1 = '' OR p.specialties::text ILIKE $1)
  AND ($2 = '' OR p.address::text ILIKE $2)
ORDER BY u.created_at DESC
LIMIT $3 OFFSET $4
`

type GetTherapistsParams struct {
	Column1 interface{}
	Column2 interface{}
	Limit   int32
	Offset  int32
}

type GetTherapistsRow struct {
	ID          uuid.UUID
	Email       string
	DisplayName string
	Specialties []string
	Address     pqtype.NullRawMessage
	Rating      sql.NullString
}

// params: specialty text, location text, limit int, offset int
func (q *Queries) GetTherapists(ctx context.Context, arg GetTherapistsParams) ([]GetTherapistsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTherapists,
		arg.Column1,
		arg.Column2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTherapistsRow
	for rows.Next() {
		var i GetTherapistsRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.DisplayName,
			pq.Array(&i.Specialties),
			&i.Address,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
