// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const createEmptyProfile = `-- name: CreateEmptyProfile :exec
INSERT INTO profiles (user_id, display_name, bio)
VALUES ($1, '', '')
ON CONFLICT (user_id) DO NOTHING
`

// params: user_id uuid
func (q *Queries) CreateEmptyProfile(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, createEmptyProfile, userID)
	return err
}

const createOrUpdateProfile = `-- name: CreateOrUpdateProfile :one
INSERT INTO profiles (user_id, display_name, bio, phone, address, specialties, profile_extra)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (user_id) DO UPDATE SET
  display_name = EXCLUDED.display_name,
  bio = EXCLUDED.bio,
  phone = EXCLUDED.phone,
  address = EXCLUDED.address,
  specialties = EXCLUDED.specialties,
  profile_extra = EXCLUDED.profile_extra,
  updated_at = now()
RETURNING id
`

type CreateOrUpdateProfileParams struct {
	UserID       uuid.UUID
	DisplayName  sql.NullString
	Bio          sql.NullString
	Phone        sql.NullString
	Address      pqtype.NullRawMessage
	Specialties  []string
	ProfileExtra pqtype.NullRawMessage
}

// params: user_id uuid, display_name text, bio text, phone text, address jsonb, specialties text[], profile_extra jsonb
// result: id uuid
func (q *Queries) CreateOrUpdateProfile(ctx context.Context, arg CreateOrUpdateProfileParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createOrUpdateProfile,
		arg.UserID,
		arg.DisplayName,
		arg.Bio,
		arg.Phone,
		arg.Address,
		pq.Array(arg.Specialties),
		arg.ProfileExtra,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password_hash, role)
VALUES ($1, $2, $3)
RETURNING id
`

type CreateUserParams struct {
	Email        string
	PasswordHash string
	Role         string
}

// params: email text, password_hash text, role text
// result: id uuid
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Email, arg.PasswordHash, arg.Role)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const getProfileByUserID = `-- name: GetProfileByUserID :one
SELECT id, user_id, display_name, bio, phone, address, specialties, profile_extra, created_at, updated_at
FROM profiles
WHERE user_id = $1
`

type GetProfileByUserIDRow struct {
	ID           uuid.UUID
	UserID       uuid.UUID
	DisplayName  sql.NullString
	Bio          sql.NullString
	Phone        sql.NullString
	Address      pqtype.NullRawMessage
	Specialties  []string
	ProfileExtra pqtype.NullRawMessage
	CreatedAt    time.Time
	UpdatedAt    time.Time
}

// params: user_id uuid
func (q *Queries) GetProfileByUserID(ctx context.Context, userID uuid.UUID) (GetProfileByUserIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileByUserID, userID)
	var i GetProfileByUserIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DisplayName,
		&i.Bio,
		&i.Phone,
		&i.Address,
		pq.Array(&i.Specialties),
		&i.ProfileExtra,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProfileWithUserInfo = `-- name: GetProfileWithUserInfo :one
SELECT COALESCE(p.rating, 0) as rating, u.email, u.role
FROM profiles p
JOIN users u ON u.id = p.user_id
WHERE p.user_id = $1
`

type GetProfileWithUserInfoRow struct {
	Rating string
	Email  string
	Role   string
}

// params: user_id uuid
func (q *Queries) GetProfileWithUserInfo(ctx context.Context, userID uuid.UUID) (GetProfileWithUserInfoRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileWithUserInfo, userID)
	var i GetProfileWithUserInfoRow
	err := row.Scan(&i.Rating, &i.Email, &i.Role)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, role, created_at, updated_at
FROM users
WHERE email = $1
`

// params: email text
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, role, created_at, updated_at
FROM users
WHERE id = $1
`

// params: id uuid
func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
